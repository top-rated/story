name: Apply patch from comment (always-run hardened)

on:
  issue_comment:
    types: [created, edited]
  pull_request_review_comment:
    types: [created, edited]

permissions:
  contents: write
  pull-requests: write
  issues: write

concurrency:
  group: apply-${{ github.event.repository.full_name }}
  cancel-in-progress: false

jobs:
  apply:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Gate by collaborator permissions
        id: gate
        uses: actions/github-script@v7
        with:
          script: |
            const { context, core, github } = require('@actions/github');
            const { owner, repo } = context.repo;
            // Only issue/pr comments are supported; skip safely for other targets.
            const login = context.payload?.comment?.user?.login || '';
            if (!login) {
              core.setOutput('allowed', 'false');
              core.setOutput('reason', 'No commenter login found.');
              return;
            }
            try {
              const { data } = await github.repos.getCollaboratorPermissionLevel({ owner, repo, username: login });
              const level = data?.permission || 'none';
              const ok = ['admin','write','maintain'].includes(level);
              core.info(`Commenter @${login} permission: ${level}`);
              core.setOutput('allowed', ok ? 'true' : 'false');
              core.setOutput('reason', ok ? '' : `Permission '${level}' not allowed`);
            } catch (e) {
              core.setOutput('allowed', 'false');
              core.setOutput('reason', `Failed to query permission: ${e.message}`);
            }

      - name: Stop if not allowed
        if: steps.gate.outputs.allowed != 'true'
        run: |
          echo "::notice ::Skipped: ${{ steps.gate.outputs.reason }}"
          exit 0

      - name: Prepare tools
        run: |
          sudo apt-get update
          sudo apt-get install -y patch

      - name: Save comment body
        run: |
          cat > body.txt <<'EOF'
          ${{ github.event.comment.body }}
          EOF

      - name: Extract mode/message and patch
        id: extract
        env:
          COMMENT_BODY: ${{ github.event.comment.body }}
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
import os, re, html, sys, json, base64

body = os.environ.get('COMMENT_BODY','')
# Normalize
body = html.unescape(body)
body = body.replace('\r\n','\n').replace('\r','\n')
for ch in ['\ufeff','\u200b','\u200c','\u200d','\xa0']:
    body = body.replace(ch, '')

# Determine command and message
cmd = 'apply-main'
msg = ''
m = re.search(r'/(apply-main|apply-pr)\b\s*(.*)', body, re.IGNORECASE)
if m:
    cmd = m.group(1).lower()
    msg = (m.group(2) or '').strip()

# Extract diff chunks from fenced code blocks (```diff, ```patch, with or without language)
chunks = []
for pat in [
    r'(?:```|~~~)\s*(?:diff|patch)?\s*\n(.*?)(?:```|~~~)',
]:
    for mm in re.finditer(pat, body, re.DOTALL | re.IGNORECASE):
        chunk = (mm.group(1) or '').strip()
        if chunk:
            chunks.append(chunk)

# Fallback: raw 'diff --git' presence
if not chunks:
    i = body.find('diff --git ')
    if i != -1:
        chunks = [ body[i:].strip() ]

# Filter to likely-unified diffs
filtered = []
for c in chunks:
    if 'diff --git ' in c or c.startswith('Index: ') or c.startswith('--- '):
        filtered.append(c.strip())

patch = "\n\n".join(filtered).strip()
if patch and not patch.endswith('\n'):
    patch += '\n'

open('patch.diff','w',encoding='utf-8').write(patch)
open('mode.txt','w').write(cmd)
open('message.txt','w').write(msg if msg else 'apply patch from comment')
PY
          echo "MODE=$(cat mode.txt)" >> $GITHUB_ENV
          echo "MSG=$(cat message.txt)" >> $GITHUB_ENV
          if [ ! -s patch.diff ]; then
            echo "::notice ::No diff found in the comment (use a fenced ```diff block)."
            echo "NO_PATCH=1" >> $GITHUB_ENV
          else
            echo "NO_PATCH=0" >> $GITHUB_ENV
          fi

      - name: Exit if no patch
        if: env.NO_PATCH == '1'
        run: exit 0

      - name: Create working branch
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git fetch origin main
          git checkout -B apply/${{ github.run_id }} origin/main

      - name: Try apply (git apply --index)
        id: strat1
        continue-on-error: true
        run: git apply --index --whitespace=nowarn --ignore-space-change --ignore-whitespace patch.diff

      - name: Try apply (git apply --reject)
        id: strat2
        if: steps.strat1.outcome != 'success'
        continue-on-error: true
        run: |
          git reset --hard
          git checkout -B apply/${{ github.run_id }} origin/main
          git apply --reject --whitespace=nowarn patch.diff
          git add -A

      - name: Try apply (patch -p1 --forward)
        id: strat3
        if: steps.strat1.outcome != 'success' && steps.strat2.outcome != 'success'
        continue-on-error: false
        run: |
          git reset --hard
          git checkout -B apply/${{ github.run_id }} origin/main
          patch -p1 --forward < patch.diff
          git add -A

      - name: Check staged changes
        run: |
          if [ -z "$(git diff --cached --name-only)" ]; then
            echo "::notice ::No changes staged (already applied or empty patch)."
            exit 0
          fi
          git status --porcelain=v1 > status.txt
          echo "Changed files:"
          cat status.txt

      - name: Decide PR or direct commit
        id: route
        shell: bash
        run: |
          set -euo pipefail
          NEED_PR="false"
          if grep -E '^\.github/workflows/' status.txt >/dev/null 2>&1; then
            NEED_PR="true"
          fi
          if [ "$(cat mode.txt)" = "apply-pr" ]; then
            NEED_PR="true"
          fi
          echo "NEED_PR=$NEED_PR" >> $GITHUB_ENV

      - name: Commit
        run: |
          git commit -m "${MSG}" || true

      - name: Push to branch (for PR)
        if: env.NEED_PR == 'true'
        shell: bash
        run: |
          set -euo pipefail
          BR="chatgpt/apply-${{ github.event.comment.id }}"
          git push --force origin HEAD:$BR
          echo "BRANCH=$BR" >> $GITHUB_ENV

      - name: Open PR
        if: env.NEED_PR == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { context, core, github } = require('@actions/github');
            const { owner, repo } = context.repo;
            const title = process.env.MSG || 'Apply patch from comment';
            const head = process.env.BRANCH;
            const base = 'main';
            const body = `Automated from ${context.payload.comment.html_url}`;
            const { data } = await github.pulls.create({ owner, repo, title, head, base, body });
            core.setOutput('url', data.html_url);

      - name: Push to main (direct)
        if: env.NEED_PR != 'true'
        shell: bash
        run: git push origin HEAD:main

      - name: Comment result
        uses: actions/github-script@v7
        with:
          script: |
            const { context, github } = require('@actions/github');
            const { owner, repo } = context.repo;
            let msg;
            if (process.env.NEED_PR === 'true') {
              msg = `✅ Patch applied to branch \`${process.env.BRANCH}\` and PR opened.`;
            } else {
              msg = `✅ Patch committed to \`main\`.`;
            }
            await github.issues.createComment({
              owner, repo,
              issue_number: context.payload.issue.number,
              body: msg
            });
